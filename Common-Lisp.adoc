= Quick notes on Common Lisp
:Author: Nguyễn Hà Dương (cmpitg)
:Email: <cmpitg@gmail.com>
:toc: left
:toclevels: 4
:numbered:
:source-highlighter: pygments
:pygments-css: class
:icons: font
:imagesdirs: ../assets/images

IMPORTANT: Code examples

* http://rosettacode.org

* http://www.cliki.net/current%20recommended%20libraries

* Notes about peek-char

* Notes about discard-next-char

* Notes about `(read input-stream t nil t)` idiom:
** `(with-input-from-string (is " ") (read is nil 'the-end))` returns `THE-END`
** `(with-input-from-string (is " ") (read is t <anything>))` throws error.
** `recursive-p` is `t` means we expect this `read` call is inside a reader macro

* Notes about `read-delimited-list` and reader macro: http://www.lispworks.com/documentation/HyperSpec/Body/f_rd_del.htm

* Notes about writing reader macro in JSON: https://gist.github.com/chaitanyagupta/9324402

* Notes about writing reader macros in practice with https://common-lisp.net/project/named-readtables/

* Notes about extracting filename and extracting file extensions.

* Notes about readtable:
** Custom vector literal
** https://common-lisp.net/project/named-readtables/

* Good utils:
** https://github.com/vseloved/rutils
** https://github.com/vseloved/rutils/blob/master/docs/ann-rutils.md

'''

== Tips and tricks

=== Suppressing banner

For SBCL: use `--noinform` argument when starting.

=== Getting current working directory

* Avoid `*default-pathname-defaults*`, it's implementation-dependent.
* (SBCL) SBCL: `(sb-posix:getcwd)`.

[source,lisp,linenums]
----
;; Require cl-cwd
(cl-cwd:get-cwd)

;; Require osicat
(osicat:current-directory)
----

=== Changing current working directory/`cd`

[source,lisp,linenums]
----
;; Only in SBCL
(sb-posix:cwd "/tmp")

;; Require cl-cwd
(cl-cwd:cwd "/tmp")

;; Require cl-cwd, when you'd like to change it temporarily
(cl-cwd:with-cwd "/tmp/"
  (format t "~A" (directory (make-pathname :directory '(:relative ".")
                                           :name :wild
                                           :type :wild))))
----


=== Getting current file

`*load-truename*` or `*load-pathname*`, returning truename and pathname,
respectively.

=== Reading/slurping file

Avoid using `open` and `close` as 1) it's error-prone, and 2) the file might
not properly closed if you don't properly handle it.  Instead, use
`with-open-file`.

* Simplest way to read a line from a file:
+
[source,lisp,linenums]
----
(with-open-file (in #P"/tmp/tmp.txt")
  (format t "~A~%" (read-line in)))
----

* Reading binary:
+
[source,lisp,linenums]
----
(with-open-file (in #P"/tmp/tmp.txt" :element-type '(unsigned-byte 8))
  (read-byte in))
----


* Useful functions: `read-line`, `read-char`, `peek-char`, `file-position`
  (jumping to a position).

* To read whole file:

** The best way is probably to use `read-utf-8-string` from `trivial-utf-8`
   library:
+
[source,lisp,linenums]
----
(defun slurp (filespec)
  "Reads and returns the whole file as string."
  (with-open-file (in filespec :element-type '(unsigned-byte 8))
    (trivial-utf-8:read-utf-8-string in :stop-at-eof t)))
----

** Or if you don't care about encoding thing and just want to read ASCII, one
   way is to use `read-sequence` with `file-length` to read the content of the
   file into a string:
+
[source,lisp,linenums]
----
(with-open-file (in #P"/tmp/tmp.txt")
  (let ((seq (make-string (file-length in))))
    (read-sequence seq in)
    seq))
----

=== Merging paths

[source,lisp,linenums]
----
(merge-pathnames #P"lib/misc" #P"/home/batman")  ;; ⇨ #P"/home/lib/misc"
(merge-pathnames #P"lib/misc" #P"/home/batman/") ;; ⇨ #P"/home/batman/lib/misc"
(merge-pathnames #P"lib/misc" #P"home/batman")   ;; ⇨ #P"home/lib/misc"
(merge-pathnames #P"lib/misc" #P"home/batman/")  ;; ⇨ #P"home/batman/lib/misc"
----

=== Getting path to a system loaded with ASDF

[source,lisp,linenums]
----
(asdf:system-source-directory :optima) ;; ⇨ #P"/home/batman/quicklisp/dists/quicklisp/software/optima-20150302-git/"
----

=== Writing to file

* Write when file doesn't exist.  The following code will signal an error if
  `/tmp/tmp.txt` exists:
+
[source,lisp,linenums]
----
(with-open-file (out #P"/tmp/tmp.txt" :direction :output)
  (format t "Hello World~%"))
----

* Overwrite if file exists.  Note that `:if-exists` is `:supersude`, **not** `:overwrite`:
+
[source,lisp,linenums]
----
(with-open-file (out #P"/tmp/tmp.txt"
                     :direction :output
                     :if-exists :supersede)
  (format out "Xin chào thế giới~%"))
----
* Overwrite, starting from the beginning of the file.  Note that Note that `:if-exists` is `:overwrite`:
+
[source,lisp,linenums]
----
(with-open-file (out #P"/tmp/tmp.txt"
                     :direction :output
                     :if-exists :supersede)
  (format out "Hello world!~%"))

(with-open-file (out #P"/tmp/tmp.txt"
                     :direction :output
                     :if-exists :overwrite)
  (format out "Bye  "))

(with-open-file (in #P"/tmp/tmp.txt")
  (read-line in))
;;; ⇨ "Bye  world!
----
* Write binary:
+
[source,lisp,linenums]
----
(with-open-file (out #P"/tmp/abc.txt"
                     :direction :output
                     :element-type '(unsigned-byte 8))
  (write-byte 97 out)
  (write-byte 98 out)
  (write-byte 99 out))
;;; Write out "abc"
----

=== Listing directory

With `cl-pad` library:

[source,lisp,linenums]
----
(cl-pad:list-directory #P"/tmp/")                      ;; ⇨ List
(cl-pad:list-directory #P"/tmp/" :follow-symlinks t)   ;; ⇨ List
----

=== Checking if a file or directory exists

Either `probe-file` or `cl-fad`'s `file-exists` would work.

[source,lisp,linenums]
----
(probe-file #P"/home/batman")           ;; ⇨ #P"/home/batman/"
(cl-fad:file-exists-p #P"/home/batman") ;; ⇨ #P"/home/batman/"
(cl-fad:file-exists-p #P"/home/batma")  ;; ⇨ NIL
----

==== Checking directory exists only

With `cl-fad` library:

[source,lisp,linenums]
----
(cl-fad:directory-exists-p #P"/home/cmpitg") ;; ⇨ #P"/home/cmpitg/"
(cl-fad:directory-exists-p #P"/tmp/tmp.txt") ;; ⇨ NIL
----

=== Calculating MD5 of a string

With `ironclad` library:

[source,lisp,linenums]
----
(defun md5 (str)
  "Calculates MD5 hash of a string."
  (ironclad:byte-array-to-hex-string
   (ironclad:digest-sequence :md5 
                             (ironclad:ascii-string-to-byte-array str))))
----

=== Merging pathnames

With `cl-fad` library:

[source,lisp,linenums]
----
(path:catfile #P"/home/cmpitg" "tmp.txt")                    ;; ⇨ #P"/home/tmp.txt"
(path:catfile #P"/home/cmpitg/" "tmp.txt")                   ;; ⇨ #P"/home/cmpitg/tmp.txt"
(cl-fad:merge-pathnames-as-file #P"/home/cmpitg" "tmp.txt")  ;; ⇨ #P"/home/tmp.txt"
(cl-fad:merge-pathnames-as-file #P"/home/cmpitg/" "tmp.txt") ;; ⇨ #P"/home/cmpitg/tmp.txt"
----

=== `cd` to directory of current loading file

With `cl-cwd` and `cl-fad` libraries:

[source,lisp,linenums]
----
(use-package :cl-cwd)
(use-package :cl-fad)
(cwd (path:basename *load-truename*))
----

=== Using temporary file

``cl-fad``'s `open-temporary` opens a temporary file and returns the stream
corresponding to that file.  For conveniences, `with-output-to-temporary-file`
is often a better suit.

[source,lisp,linenums]
----
(cl-fad:with-output-to-temporary-file (out)
  (format out "Hello World"))
;; ⇨ #P"/tmp/temp-yccc29mc"

(with-open-file (in #P"/tmp/temp-yccc29mc")
  (read-line in))
;; ⇨ "Hello World"
----

=== Extracting dirname/parent directory

* Plain old Common Lisp:
+
[source,lisp,linenums]
----
(directory-namestring "/home/batman")  ;; ⇨ "/home/"
(directory-namestring "/home/batman/") ;; ⇨ "/home/batman/"
----

* With `path` package from `cl-fad` library:
+
[source,lisp,linenums]
----
(use-package :cl-fad)

(path:dirname #P"/home/batman")  ;; ⇨ #P"/home/"
(path:dirname #P"/home/batman/") ;; ⇨ #P"/home/batman/"
----

* Or with `cl-pad` directly:
+
[source,lisp,linenums]
----
(cl-fad:pathname-directory-pathname #P"/home/batman")            ;; ⇨ #P"/home/"
(cl-fad:pathname-directory-pathname #P"/home/batman/")           ;; ⇨ #P"/home/batman/"
(cl-fad:pathname-directory-pathname #P"/home/batman/hello.txt")  ;; ⇨ #P"/home/batman/"
----

=== Extracting basename/filename

* With `path` package from `cl-fad` library:
+
[source,lisp,linenums]
----
(path:basename #P"/home/batman")  ;; ⇨ #P"batman"
(path:basename #P"/home/batman/") ;; ⇨ #P""
----

* Or with plain old Common Lisp standard:
+
[source,lisp,linenums]
----
(file-namestring #P"/home/batman")  ;; ⇨ "batman"
(file-namestring #P"/home/batman/") ;; ⇨ ""
----

=== Comparing pathnames

With `cl-fad` library

[source,lisp,linenums]
----
(equalp #P"/home/batman" "/home/batman") ;; ⇨ NIL

(use-package :cl-fad)
(path:= #P"/home/batman" "/home/batman") ;; ⇨ T
----

== FAQs

=== What is truename?

From
http://www.lispworks.com/documentation/lw51/CLHS/Body/20_ac.htm[HyperSpec]:

[quote]
____
Truename is a pathname with any file system-level translations such as
resolving symbolic links performed.
____

=== Difference between physical and logical pathname?

* From
  http://www.lispworks.com/documentation/lw51/CLHS/Body/t_logica.htm[HyperSpec]:
+
[quote]
____
(Logical pathname is) A pathname that uses a namestring syntax that is
implementation-independent, and that has component values that are
implementation-independent
____

* From http://www.gigamonkeys.com/book[Practical Common Lisp]:
+
[quote]
____
Logical pathnames allow Common Lisp programs to contain references to
pathnames without naming specific files. Logical pathnames could then be
mapped to specific locations in an actual file system when the program was
installed by defining a "logical pathname translation" that translates logical
pathnames matching certain wildcards to pathnames representing files in the
file system, so-called physical pathnames.
____

In modern system, it's safe to ignore the difference between logical and
physical pathnames.


Truename is a pathname with any file system-level translations such as resolving symbolic links performed.
